<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode 866:回文素数]]></title>
    <url>%2F2019%2F02%2F23%2FLeetCode-866%2F</url>
    <content type="text"><![CDATA[回文素数题意 123456789求出大于或等于 N 的最小回文素数。回顾一下，如果一个数大于 1，且其因数只有 1 和它自身，那么这个数是素数。例如，2，3，5，7，11 以及 13 是素数。回顾一下，如果一个数从左往右读与从右往左读是一样的，那么这个数是回文数。例如，12321 是回文数。 示例1：12输入：6输出：7 示例2：12输入：8输出：11 示例3：123输入：13输出：101 提示： 1&lt;= N &lt;=10^8 答案肯定存在，且小于 2*10^8。 题解 最先的想法是穷举每一个比N大的数，检验回文和是否为素数，明显超时。 我的做法是穷举比N大的回文数，然后检查是否为质数。 判断质数的时候我采用先把素数表打好的办法，然后检查是否能整除素数。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133class Solution &#123;public: int Prime[20000];int Prime_number; int len(int x)//求x的位数 &#123; int ans=0; while(x&gt;0) &#123; ++ans;x/=10; &#125; return ans; &#125; int StringToInt(const string &amp;s) &#123; int lens=s.length();int x=0; for(int i=lens-1;i&gt;=0;--i) &#123; x*=10;x+=s[i]-'0'; &#125; return x; &#125; string travase(const string &amp;s) &#123; int lens=s.length();int x=0;string ans=""; for(int i=lens-1;i&gt;=0;--i) ans=ans+s[i]; return ans; &#125; int Make_Palindrome(int x,bool odd) &#123; if(odd) &#123; string s=to_string(x/10); if(x/10==0) s=""; s=s+to_string(x%10)+travase(s); return StringToInt(s); &#125; else &#123; string s=to_string(x); s=s+travase(s); return StringToInt(s); &#125; &#125; int power1(int n)//10的n次 &#123; int ans=1; for(int i=1;i&lt;=n;++i) ans*=10; return ans; &#125; int Number_Next(int x) &#123; int lenx=len(x); if(lenx&amp;1) &#123; int y=x/power1(lenx/2); int tmp=Make_Palindrome(y,true); if(tmp&gt;x) return tmp; ++y; if(len(y)&gt;lenx/2+1) x=Make_Palindrome(y/10,false); else x=Make_Palindrome(y,true); &#125; else &#123; int y=x/power1(lenx/2); int tmp=Make_Palindrome(y,false); if(tmp&gt;x) return tmp; ++y; if(len(y)&gt;lenx/2) x=Make_Palindrome(y,true); else x=Make_Palindrome(y,false); &#125; return x; &#125; bool Check_Palindrome(int x) &#123; string s1=to_string(x),s2=travase(s1); if(s1==s2) return true; return false; &#125; bool Check_Prime(int x) &#123; for(int i=1;i&lt;=Prime_number&amp;&amp;Prime[i]*Prime[i]&lt;=x;++i) if(x%Prime[i]==0) return false; return true; &#125; int primePalindrome(int N) &#123; if(N==1||N==2) return 2; int flag[20000]=&#123;0&#125;;Prime_number=0; for(int i=2;i&lt;15000;++i) &#123; if(!flag[i]) Prime[++Prime_number]=i; for(int j=1;j&lt;=Prime_number&amp;&amp;i*Prime[j]&lt;15000;++j) flag[i*Prime[j]]=true; &#125; if(Check_Palindrome(N)&amp;&amp;Check_Prime(N)) return N; while(true) &#123; N=Number_Next(N); if(!N&amp;1) &#123; int lenn=len(N); if(lenn&amp;1) &#123; int x=N%10+1;x=x*power1(lenn/2);x=Make_Palindrome(x,true);N=x; &#125; else &#123; int x=N%10+1; x=x*power1(lenn/2-1);x=Make_Palindrome(x,false);N=x; &#125; &#125; if(Check_Prime(N)) return N; &#125; return N; &#125;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天才的诞生]]></title>
    <url>%2F2019%2F02%2F17%2Fn1%2F</url>
    <content type="text"><![CDATA[一.一天夜晚 夜晚，梁碧月肚子痛得不行。恐怕是要生，张若志想送医院，却没有钱。只得找了一个当兽医的朋友，帮忙接生了。 在”手术室”外，张若志累晕了。醒来时，兽医朋友对他说:“恭喜。两个男孩子。 他十分高兴，但又十分悲痛。因为两个孩子，他们抚养不起。 二.灵 孩子百日了，却还没有名字。若志把大儿子取名精生，小儿取名中成。 一日，精生摆弄着家里的地唯一一台风扇。玩着玩着，“啪！” 风扇掉到了地上有些地方散了，精生并没有哭，而是动手把有些地方装好，有时候不够力就用脚踩。这一幕，张若志看见了，非常高兴。没有文化的他，只用“你太厉害了！”来形容。但是，这已经是他对别人最好的赞许了。 这是一个天才！]]></content>
      <categories>
        <category>天才的诞生</category>
      </categories>
      <tags>
        <tag>MinChe的小说</tag>
        <tag>天才的诞生系列</tag>
        <tag>小学</tag>
        <tag>小说练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Weekly Contest 124]]></title>
    <url>%2F2019%2F02%2F17%2Fmy-first-blog%2F</url>
    <content type="text"><![CDATA[1.Cousins in Binary Tree 题解 我采用的是宽搜，所以代码较长。事后想到应该用深搜会简洁很多。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isCousins(TreeNode* root, int x, int y) &#123; pair&lt;TreeNode*,int&gt; q[1000]; int fa[1000]=&#123;-1&#125;;int head=0,tail=0; int hx=-1,hy=-1;int fax=-1,fay=-1; q[0].first=root;q[0].second=0;fa[0]=-1; while(head&lt;=tail) &#123; TreeNode *now=q[head].first; if(now-&gt;val==x) &#123; fax=fa[head]; hx=q[head].second; &#125; if(now-&gt;val==y) &#123; fay=fa[head]; hy=q[head].second; &#125; if(hx!=-1&amp;&amp;hy==hx&amp;&amp;fax!=fay) return true; if(now-&gt;left!=NULL) &#123; ++tail; q[tail].first=now-&gt;left; q[tail].second=q[head].second+1; fa[tail]=now-&gt;val; &#125; if(now-&gt;right!=NULL) &#123; ++tail; q[tail].first=now-&gt;right; q[tail].second=q[head].second+1; fa[tail]=now-&gt;val; &#125; head++; &#125; return false; &#125;&#125;; 2.Rotting Oranges题解 依然是宽搜。 代码1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: int orangesRotting(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int n=grid.size(),m=grid[0].size(); int now=0,tot=0; int qx[1000],qy[1000],qt[1000];int time=0;//开三个队列，分别记录坐标和时间 int head=0,tail=-1; int dx[4]=&#123;0,1,0,-1&#125;,dy[4]=&#123;1,0,-1,0&#125;;//方向数组 for(int i=0;i&lt;n;++i) for(int j=0;j&lt;m;++j) if(grid[i][j]==1) ++tot; else if(grid[i][j]==2) &#123; ++tot;++now; qx[++tail]=i; qy[tail]=j; qt[tail]=0; &#125; while(head&lt;=tail) &#123; int x=qx[head],y=qy[head]; for(int i=0;i&lt;=3;++i) &#123; time=max(time,qt[head]); if(x+dx[i]&gt;=0&amp;&amp;y+dy[i]&gt;=0&amp;&amp;x+dx[i]&lt;n&amp;&amp;y+dy[i]&lt;m&amp;&amp;grid[x+dx[i]][y+dy[i]]==1) &#123; qx[++tail]=x+dx[i]; qy[tail]=y+dy[i]; qt[tail]=qt[head]+1; grid[x+dx[i]][y+dy[i]]=2; ++now; &#125; &#125; ++head; &#125; if(now&lt;tot) return -1; return time; &#125;&#125;; 3.Minimum Number of K Consecutive Bit Flips题解 贪心+差分。我们把每一次翻面看做一次操作，并认为是从左至右按顺序进行的。由此可以知道每次都从最左边的0开始操作。为了不用每次都修改每一个翻面的硬币的值。我们只需要利用差分的思想在头和尾进行标记。now作为当前的硬币翻面次数。 代码12345678910111213141516171819202122232425class Solution &#123;public: int minKBitFlips(vector&lt;int&gt;&amp; A, int K) &#123; int n=A.size();int now=0; int s[40000]=&#123;0&#125;;int ans=0; for(int i=0;i&lt;n;++i) &#123; now+=s[i]; if(i&lt;=n-K&amp;&amp;(A[i]+now)%2==0) &#123; ++ans;++now; ++s[i];--s[i+K]; &#125; A[i]+=now; A[i]%=2; &#125; for(int i=0;i&lt;n;++i) if(A[i]==0) return -1; return ans; &#125;&#125;; 4.Number of Squareful Arrays题解 状压dp,与旅行商问题类似。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123;public: bool check(int x)//检查一个数是否为平方数 &#123; if(floor(sqrt(x))*floor(sqrt(x))==x) return true; return false; &#125; int fac(int n)//计算阶乘 &#123; int ans=1; for(int i=2;i&lt;=n;++i) ans*=i; return ans; &#125; int numSquarefulPerms(vector&lt;int&gt;&amp; A) &#123; bool f[12][12]=&#123;0&#125;;int n=A.size();//f保存两个数是否能放在相邻的位置 for(int i=0;i&lt;n;++i) for(int j=0;j&lt;n;++j) if(i==j) continue; else if(check(A[i]+A[j])) f[i][j]=true; int s[12][1&lt;&lt;12]=&#123;0&#125;;//s[i][j],j转化成二进制后的1表明目前这个位置放了,i表示A[i]在最后 for(int i=0;i&lt;n;++i) s[i][1&lt;&lt;i]=1; for(int i=1;i&lt;1&lt;&lt;n;++i) for(int j=0;j&lt;n;++j) &#123; if((i&gt;&gt;j)&amp;1!=1) continue; for(int k=0;k&lt;n;++k) if(f[j][k]&amp;&amp;((i&gt;&gt;k)&amp;1)) s[j][i]+=s[k][i^(1&lt;&lt;j)]; &#125; int ans=0;bool flag[12]=&#123;0&#125;; for(int i=0;i&lt;n;++i) ans+=s[i][(1&lt;&lt;n)-1]; for(int i=0;i&lt;n;++i) if(!flag[i]) &#123; int count=1; for(int j=i+1;j&lt;n;++j) if(A[i]==A[j]) &#123; count++; flag[j]=true; &#125; ans/=fac(count);//去除重复的部分 &#125; return ans; &#125;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode Contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to my blog! I Will Be With You]]></content>
  </entry>
</search>
