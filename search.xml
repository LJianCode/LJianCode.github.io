<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode Weekly Contest 124]]></title>
    <url>%2F2019%2F02%2F17%2Fmy-first-blog%2F</url>
    <content type="text"><![CDATA[1.Cousins in Binary Tree 题解 我采用的是宽搜，所以代码较长。事后想到应该用深搜会简洁很多。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isCousins(TreeNode* root, int x, int y) &#123; pair&lt;TreeNode*,int&gt; q[1000]; int fa[1000]=&#123;-1&#125;;int head=0,tail=0; int hx=-1,hy=-1;int fax=-1,fay=-1; q[0].first=root;q[0].second=0;fa[0]=-1; while(head&lt;=tail) &#123; TreeNode *now=q[head].first; if(now-&gt;val==x) &#123; fax=fa[head]; hx=q[head].second; &#125; if(now-&gt;val==y) &#123; fay=fa[head]; hy=q[head].second; &#125; if(hx!=-1&amp;&amp;hy==hx&amp;&amp;fax!=fay) return true; if(now-&gt;left!=NULL) &#123; ++tail; q[tail].first=now-&gt;left; q[tail].second=q[head].second+1; fa[tail]=now-&gt;val; &#125; if(now-&gt;right!=NULL) &#123; ++tail; q[tail].first=now-&gt;right; q[tail].second=q[head].second+1; fa[tail]=now-&gt;val; &#125; head++; &#125; return false; &#125;&#125;; 2.Rotting Oranges题解 依然是宽搜。 代码1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: int orangesRotting(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int n=grid.size(),m=grid[0].size(); int now=0,tot=0; int qx[1000],qy[1000],qt[1000];int time=0;//开三个队列，分别记录坐标和时间 int head=0,tail=-1; int dx[4]=&#123;0,1,0,-1&#125;,dy[4]=&#123;1,0,-1,0&#125;;//方向数组 for(int i=0;i&lt;n;++i) for(int j=0;j&lt;m;++j) if(grid[i][j]==1) ++tot; else if(grid[i][j]==2) &#123; ++tot;++now; qx[++tail]=i; qy[tail]=j; qt[tail]=0; &#125; while(head&lt;=tail) &#123; int x=qx[head],y=qy[head]; for(int i=0;i&lt;=3;++i) &#123; time=max(time,qt[head]); if(x+dx[i]&gt;=0&amp;&amp;y+dy[i]&gt;=0&amp;&amp;x+dx[i]&lt;n&amp;&amp;y+dy[i]&lt;m&amp;&amp;grid[x+dx[i]][y+dy[i]]==1) &#123; qx[++tail]=x+dx[i]; qy[tail]=y+dy[i]; qt[tail]=qt[head]+1; grid[x+dx[i]][y+dy[i]]=2; ++now; &#125; &#125; ++head; &#125; if(now&lt;tot) return -1; return time; &#125;&#125;; 3.Minimum Number of K Consecutive Bit Flips题解贪心+差分。我们把每一次翻面看做一次操作，并认为是从左至右按顺序进行的。由此可以知道每次都从最左边的0开始操作。为了不用每次都修改每一个翻面的硬币的值。我们只需要利用差分的思想在头和尾进行标记。now作为当前的硬币翻面次数。 代码12345678910111213141516171819202122232425class Solution &#123;public: int minKBitFlips(vector&lt;int&gt;&amp; A, int K) &#123; int n=A.size();int now=0; int s[40000]=&#123;0&#125;;int ans=0; for(int i=0;i&lt;n;++i) &#123; now+=s[i]; if(i&lt;=n-K&amp;&amp;(A[i]+now)%2==0) &#123; ++ans;++now; ++s[i];--s[i+K]; &#125; A[i]+=now; A[i]%=2; &#125; for(int i=0;i&lt;n;++i) if(A[i]==0) return -1; return ans; &#125;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode Contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to my blog! I Will Be With You]]></content>
  </entry>
</search>
